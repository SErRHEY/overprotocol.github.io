"use strict";(self.webpackChunkover_docs=self.webpackChunkover_docs||[]).push([[819],{3905:(e,t,r)=>{r.d(t,{Zo:()=>h,kt:()=>f});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},h=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),u=l(r),d=o,f=u["".concat(c,".").concat(d)]||u[d]||p[d]||a;return r?n.createElement(f,i(i({ref:t},h),{},{components:r})):n.createElement(f,i({ref:t},h))}));function f(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[u]="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=r[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},403:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var n=r(7462),o=(r(7294),r(3905));const a={title:"Fees",description:"A description of OverProtocol's fee mechanisms.",lang:"en"},i=void 0,s={unversionedId:"learn/key-features/tokenomics/fee",id:"learn/key-features/tokenomics/fee",title:"Fees",description:"A description of OverProtocol's fee mechanisms.",source:"@site/docs/learn/key-features/tokenomics/fee.md",sourceDirName:"learn/key-features/tokenomics",slug:"/learn/key-features/tokenomics/fee",permalink:"/learn/key-features/tokenomics/fee",draft:!1,editUrl:"https://github.com/overprotocol/overprotocol.github.io/edit/develop/docs/learn/key-features/tokenomics/fee.md",tags:[],version:"current",frontMatter:{title:"Fees",description:"A description of OverProtocol's fee mechanisms.",lang:"en"},sidebar:"learnSidebar",previous:{title:"Deposit and Yield",permalink:"/learn/key-features/tokenomics/feedback"}},c={},l=[{value:"Currently Effective",id:"currently-effective",level:2},{value:"Transaction fee",id:"transaction-fee",level:3},{value:"Future Plans",id:"future-plans",level:2},{value:"Storage Rent Fee",id:"storage-rent-fee",level:3},{value:"Why it was hard to collect Storage Rent Fees",id:"why-it-was-hard-to-collect-storage-rent-fees",level:4},{value:"OverProtocol&#39;s Approach",id:"overprotocols-approach",level:4}],h={toc:l},u="wrapper";function p(e){let{components:t,...r}=e;return(0,o.kt)(u,(0,n.Z)({},h,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"currently-effective"},"Currently Effective"),(0,o.kt)("h3",{id:"transaction-fee"},"Transaction fee"),(0,o.kt)("p",null,"The ",(0,o.kt)("strong",{parentName:"p"},"Transaction Fee")," is a charge applied to each transaction within the OverProtocol's on-chain activity. This fee serves to reduce the total circulating supply of OVER tokens."),(0,o.kt)("p",null,"There are two primary objectives that we aim to achieve through the transaction fee design. Firstly, we seek to align user gas usage with an appropriate gas target, ensuring efficient network operation. Secondly, we aim to induce deflationary pressure through the application of ",(0,o.kt)("strong",{parentName:"p"},"base fees"),", thereby promoting a balanced economic environment within the network. For this purpose, we use the commonly known EIP-1559, and adjust its design which we plan to achieve through several future updates."),(0,o.kt)("p",null,"In the protocol's initial stages, the base fee is collected and directed to the ",(0,o.kt)("a",{parentName:"p",href:"/learn/key-features/tokenomics/distribution#treasury"},"DAO Treasury"),", supporting various ecosystem development initiatives. As the protocol matures, the collection strategy evolves: instead of accruing in the treasury, the base fee is directly burned from each transaction. This nuanced approach balances the initial growth needs with a longer-term strategy of reducing token supply, thereby sustaining the protocol\u2019s economic health."),(0,o.kt)("h2",{id:"future-plans"},"Future Plans"),(0,o.kt)("h3",{id:"storage-rent-fee"},"Storage Rent Fee"),(0,o.kt)("p",null,"The ",(0,o.kt)("strong",{parentName:"p"},"Storage rent fee")," is a charge on the contract accounts levied every certain period. It charges the use of storing data on the blockchain and reduces the total circulating supply of the OVER tokens."),(0,o.kt)("p",null,"Storage rent is a proposed economic mechanism designed to address the inefficiency of the 'pay once, use forever' model for state storage. In traditional blockchain models, once a user pays a fee to store data or execute a transaction, the associated data remains on the blockchain indefinitely, leading to an ever-growing state. This growth poses significant scalability and efficiency challenges."),(0,o.kt)("p",null,"With the storage rent fee, a blockchain storage user would consistenly pay the rent to compensate for the ongoing use of the storage space. This fee incentivizes users to only retain necessary and actively used data, thereby managing the size and efficiency of the blockchain's state. That is, we can expect users to be more judicious about the data they store on the blockchain and to potentially clean up or remove data that is no longer needed."),(0,o.kt)("p",null,"Such a fee is levied on every Ethanos epoch, and the amount depends on the quantity of data stored with the duration for which it was stored. The storage fee is collected and directed to the ",(0,o.kt)("a",{parentName:"p",href:"/learn/key-features/tokenomics/distribution#treasury"},"DAO Treasury"),", supporting various ecosystem development initiatives."),(0,o.kt)("h4",{id:"why-it-was-hard-to-collect-storage-rent-fees"},"Why it was hard to collect Storage Rent Fees"),(0,o.kt)("p",null,"Implementing a storage rent fee design in conventional blockchain architectures is challenging due to the immense size of the state. For the protocol to levy storage rent, it must navigate through all state accounts to determine the appropriate charges and identify the account holders responsible for these fees. Additionally, the protocol needs to decide on the timing for such traversals. This process, under typical blockchain designs, presents significant complexities and operational inefficiencies, making the implementation of a storage rent fee system difficult. Consequently, in many cases, once a fee is paid for storing new values in the state, the space is occupied indefinitely, bypassing ongoing storage costs."),(0,o.kt)("h4",{id:"overprotocols-approach"},"OverProtocol's Approach"),(0,o.kt)("p",null,"Through its innovative Ethanos technique, the OverProtocol effectively manages state size and introduces periodic intervals, streamlining the process of imposing storage rent fees. This approach allows for a straightforward determination of when and which contract accounts should be charged. The whitepaper, ",(0,o.kt)("a",{parentName:"p",href:"https://drive.google.com/file/d/1DNK0FFOVhnVDRnz8h9RJ1NoDUN4W0He8/view"},"OverProtocol: Towards True Decentralization"),", elaborates on Ethanos, but here we present its core principles."),(0,o.kt)("p",null,"OverProtocol distinguishes between active and inactive accounts by resetting states at regular intervals, leveraging the consistency of activity across these cycles. Active accounts, identified by their continuous operation through cycles, are seamlessly transferred from the finalized state of the previous cycle to the current cycle's state. This transfer occurs at the first transactional interaction in the new cycle."),(0,o.kt)("p",null,"At this juncture, storage rent is levied on contract accounts, employing the efficiency of the Ethanos technique without necessitating external state traversal. This efficiency is further enhanced by the protocol's managed state size. Additionally, accounts in OverProtocol are equipped with metadata that assesses their storage size, creating a system where larger storage spaces incur higher rent. This design facilitates a fair and usage-based charging model."),(0,o.kt)("p",null,"The storage rent design is still under development, with the goal of establishing a user-friendly framework that simultaneously fosters a robust storage economy."))}p.isMDXComponent=!0}}]);