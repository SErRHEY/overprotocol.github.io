"use strict";(self.webpackChunkover_docs=self.webpackChunkover_docs||[]).push([[652],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=l(n),h=o,m=p["".concat(c,".").concat(h)]||p[h]||u[h]||a;return n?r.createElement(m,i(i({ref:t},d),{},{components:n})):r.createElement(m,i({ref:t},d))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[p]="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},8785:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var r=n(7462),o=(n(7294),n(3905));const a={title:"Differences from Ethereum",description:"A list of differences from Ethereum that can significantly impact how applications are built and function on this platform.",lang:"en"},i=void 0,s={unversionedId:"developers/differences-from-ethereum",id:"developers/differences-from-ethereum",title:"Differences from Ethereum",description:"A list of differences from Ethereum that can significantly impact how applications are built and function on this platform.",source:"@site/docs/developers/differences-from-ethereum.md",sourceDirName:"developers",slug:"/developers/differences-from-ethereum",permalink:"/developers/differences-from-ethereum",draft:!1,editUrl:"https://github.com/overprotocol/overprotocol.github.io/edit/develop/docs/developers/differences-from-ethereum.md",tags:[],version:"current",frontMatter:{title:"Differences from Ethereum",description:"A list of differences from Ethereum that can significantly impact how applications are built and function on this platform.",lang:"en"},sidebar:"developersSidebar",previous:{title:"Getting Started",permalink:"/developers/"},next:{title:"Build Your Contract",permalink:"/developers/build-your-contract/"}},c={},l=[{value:"You Can&#39;t Use the Same Contract Address in Ethereum",id:"you-cant-use-the-same-contract-address-in-ethereum",level:2},{value:"Actions to Take",id:"actions-to-take",level:3},{value:"Transaction has a <code>restoredEpoch</code> Field",id:"transaction-has-a-restoredepoch-field",level:2},{value:"RestoredEpoch",id:"restoredepoch",level:3},{value:"<code>nonce</code> Field in Transaction",id:"nonce-field-in-transaction",level:4},{value:"Actions to Take",id:"actions-to-take-1",level:3},{value:"Misc",id:"misc",level:2},{value:"<code>SELFDESTRUCT</code> Operation",id:"selfdestruct-operation",level:3}],d={toc:l},p="wrapper";function u(e){let{components:t,...n}=e;return(0,o.kt)(p,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"OverProtocol is an independent Layer 1 protocol that inherits the Ethereum Virtual Machine (EVM), ensuring compatibility with Ethereum's established ecosystem. This compatibility enables developers familiar with Ethereum to transition smoothly and leverage their existing skills. However, there are key distinctions between OverProtocol and Ethereum that developers must understand, as these differences can significantly impact how applications are built and function on this platform. Here are the crucial aspects to consider and the actions to take:"),(0,o.kt)("h2",{id:"you-cant-use-the-same-contract-address-in-ethereum"},"You Can't Use the Same Contract Address in Ethereum"),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"While the same Externally Owned Account (EOA) address can be used across various EVM-compatible chains with the same private key, this does not apply to contract addresses.")),(0,o.kt)("p",null,"Due to the state expiry feature in OverProtocol, even if the feature is currently disabled, to mitigate the risk of an expired contract address being reused by a newly created contract, the contract creation operation always incorporates the caller account's ",(0,o.kt)("inlineCode",{parentName:"p"},"restoredEpoch")," value. This inclusion alters the outcome of the ",(0,o.kt)("inlineCode",{parentName:"p"},"CREATE")," operation, making the resulting addresses differ from those on other EVM chains."),(0,o.kt)("p",null,"As a result, even though the ",(0,o.kt)("inlineCode",{parentName:"p"},"CREATE2")," operation allows for deterministic address prediction and usage, it is not possible to reuse the same address across different chains as you would with EOA addresses."),(0,o.kt)("h3",{id:"actions-to-take"},"Actions to Take"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Be aware that contract addresses on OverProtocol will differ from those on Ethereum and other EVM-compatible chains due to the inclusion of the ",(0,o.kt)("inlineCode",{parentName:"li"},"restoredEpoch")," value."),(0,o.kt)("li",{parentName:"ul"},"When deploying contracts, account for the different address derivation method and plan your deployment strategy accordingly.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"// Create creates a new contract using code as deployment code.\nfunc (evm *EVM) Create(caller ContractRef, code []byte, gas uint64, value *big.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) {\n  contractAddr = crypto.CreateAddress(caller.Address(), evm.StateDB.GetRestoredEpoch(caller.Address()), evm.StateDB.GetNonce(caller.Address()))\n  return evm.create(caller, &codeAndHash{code: code}, gas, value, contractAddr, CREATE)\n}\n\n// Create2 creates a new contract using code as deployment code.\n//\n// The different between Create2 with Create is Create2 uses keccak256(0xff ++ msg.sender ++ salt ++ keccak256(init_code))[12:]\n// instead of the usual sender-and-nonce-hash as the address where the contract is initialized at.\nfunc (evm *EVM) Create2(caller ContractRef, code []byte, gas uint64, endowment *big.Int, salt *uint256.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) {\n  codeAndHash := &codeAndHash{code: code}\n  contractAddr = crypto.CreateAddress2(caller.Address(), salt.Bytes32(), codeAndHash.Hash().Bytes())\n  return evm.create(caller, codeAndHash, gas, endowment, contractAddr, CREATE2)\n}\n")),(0,o.kt)("h2",{id:"transaction-has-a-restoredepoch-field"},"Transaction has a ",(0,o.kt)("inlineCode",{parentName:"h2"},"restoredEpoch")," Field"),(0,o.kt)("p",null,"In traditional blockchain architectures, the ",(0,o.kt)("inlineCode",{parentName:"p"},"nonce")," primarily tracks the number of transactions sent from a given account, ensuring transaction order and preventing double-spending. However, due to the expiration feature in OverProtocol, distinguishing explicitly between expired accounts and newly created accounts becomes challenging, raising the possibility of ",(0,o.kt)("inlineCode",{parentName:"p"},"nonce")," overlap. To address this issue, OverProtocol introduces the ",(0,o.kt)("inlineCode",{parentName:"p"},"restoredEpoch")," as a crucial component."),(0,o.kt)("h3",{id:"restoredepoch"},"RestoredEpoch"),(0,o.kt)("p",null,"The combination of the ",(0,o.kt)("inlineCode",{parentName:"p"},"nonce")," and the ",(0,o.kt)("inlineCode",{parentName:"p"},"restoredEpoch")," value ensures uniqueness for each account. This system allows OverProtocol to maintain the integrity and distinction of account states over time, even through periods of account inactivity and expiration."),(0,o.kt)("p",null,"For a more detailed explanation, please refer to the ",(0,o.kt)("a",{parentName:"p",href:"/learn/key-features/layered-architecture/ethanos#dealing-with-crumb-accounts-restored-epoch"},"documentation"),"."),(0,o.kt)("h4",{id:"nonce-field-in-transaction"},(0,o.kt)("inlineCode",{parentName:"h4"},"nonce")," Field in Transaction"),(0,o.kt)("p",null,"The existing ",(0,o.kt)("inlineCode",{parentName:"p"},"nonce")," field is split into a 64-bit field, with the first 32 bits representing the ",(0,o.kt)("inlineCode",{parentName:"p"},"restoredEpoch")," and the remaining 32 bits functioning as the traditional ",(0,o.kt)("inlineCode",{parentName:"p"},"nonce"),". This adaptation allows developers to leverage existing Ethereum development environments while accommodating the unique features of OverProtocol."),(0,o.kt)("h3",{id:"actions-to-take-1"},"Actions to Take"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Learn how ",(0,o.kt)("inlineCode",{parentName:"li"},"restoredEpoch")," functions and its interaction with the nonce to ensure each account's uniqueness."),(0,o.kt)("li",{parentName:"ul"},"Use RPC requests like ",(0,o.kt)("inlineCode",{parentName:"li"},"eth_getTransactionCount")," when making transactions. The response will include the correct ",(0,o.kt)("inlineCode",{parentName:"li"},"nonce")," value, considering both ",(0,o.kt)("inlineCode",{parentName:"li"},"nonce")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"restoredEpoch"),".")),(0,o.kt)("h2",{id:"misc"},"Misc"),(0,o.kt)("h3",{id:"selfdestruct-operation"},(0,o.kt)("inlineCode",{parentName:"h3"},"SELFDESTRUCT")," Operation"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"SELFDESTRUCT")," opcode, updated in accordance with ",(0,o.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-6780"},(0,o.kt)("inlineCode",{parentName:"a"},"EIP-6780")),", is implemented in such a way that while it does not actually destroy the contract account, it does process refunds. Contracts that are not used will naturally expire over time as the Ethanos epoch progresses."),(0,o.kt)("p",null,"The rationale behind incorporating EIP-6780 into OverProtocol differs significantly from its application in Ethereum. OverProtocol's implementation is specifically designed to avoid scenarios where a self-destructed contract account becomes indistinguishable from an Externally Owned Account (EOA). This distinction is crucial for maintaining clarity and integrity in the network's account management, ensuring that the lifecycle of contract accounts is handled in a better way."))}u.isMDXComponent=!0}}]);