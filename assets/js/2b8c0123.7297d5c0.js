"use strict";(self.webpackChunkover_docs=self.webpackChunkover_docs||[]).push([[652],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=l(n),h=o,m=u["".concat(c,".").concat(h)]||u[h]||p[h]||r;return n?a.createElement(m,i(i({ref:t},d),{},{components:n})):a.createElement(m,i({ref:t},d))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[u]="string"==typeof e?e:o,i[1]=s;for(var l=2;l<r;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},8785:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var a=n(7462),o=(n(7294),n(3905));const r={title:"Differences from Ethereum",description:"A list of differences from Ethereum that can significantly impact how applications are built and function on this platform.",lang:"en"},i=void 0,s={unversionedId:"developers/differences-from-ethereum",id:"developers/differences-from-ethereum",title:"Differences from Ethereum",description:"A list of differences from Ethereum that can significantly impact how applications are built and function on this platform.",source:"@site/docs/developers/differences-from-ethereum.md",sourceDirName:"developers",slug:"/developers/differences-from-ethereum",permalink:"/developers/differences-from-ethereum",draft:!1,editUrl:"https://github.com/overprotocol/overprotocol.github.io/edit/develop/docs/developers/differences-from-ethereum.md",tags:[],version:"current",frontMatter:{title:"Differences from Ethereum",description:"A list of differences from Ethereum that can significantly impact how applications are built and function on this platform.",lang:"en"},sidebar:"developersSidebar",previous:{title:"Getting Started",permalink:"/developers/"},next:{title:"Build Your Contract",permalink:"/developers/build-your-contract/"}},c={},l=[{value:"Your Accounts Can Be Expired",id:"your-accounts-can-be-expired",level:2},{value:"Actions to Take",id:"actions-to-take",level:3},{value:"You Can&#39;t Use the Same Contract Address in Ethereum",id:"you-cant-use-the-same-contract-address-in-ethereum",level:2},{value:"Actions to Take",id:"actions-to-take-1",level:3},{value:"Transaction has a <code>restoredEpoch</code> Field",id:"transaction-has-a-restoredepoch-field",level:2},{value:"RestoredEpoch",id:"restoredepoch",level:3},{value:"<code>nonce</code> Field in Transaction",id:"nonce-field-in-transaction",level:4},{value:"Actions to Take",id:"actions-to-take-2",level:3},{value:"Misc",id:"misc",level:2},{value:"<code>SELFDESTRUCT</code> Operation",id:"selfdestruct-operation",level:3},{value:"Future Changes",id:"future-changes",level:2},{value:"Storage Layout Change",id:"storage-layout-change",level:3}],d={toc:l},u="wrapper";function p(e){let{components:t,...n}=e;return(0,o.kt)(u,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"OverProtocol is an independent Layer 1 protocol that inherits the Ethereum Virtual Machine (EVM), ensuring compatibility with Ethereum's established ecosystem. This compatibility enables developers familiar with Ethereum to transition smoothly and leverage their existing skills. However, there are key distinctions between OverProtocol and Ethereum that developers must understand, as these differences can significantly impact how applications are built and function on this platform. Here are the crucial aspects to consider and the actions to take:"),(0,o.kt)("h2",{id:"your-accounts-can-be-expired"},"Your Accounts Can Be Expired"),(0,o.kt)("p",null,"In OverProtocol, inactive accounts are subject to expiration. ",(0,o.kt)("a",{parentName:"p",href:"/learn/key-features/layered-architecture/ethanos"},"This mechanism")," optimizes network efficiency and scalability by reducing the overhead of maintaining dormant accounts. Account restoration involves ",(0,o.kt)("a",{parentName:"p",href:"/learn/key-features/layered-architecture/ethanos#restoration-transaction"},"a new transaction type")," and additional EVM functionalities rather than opcode-level implementation."),(0,o.kt)("p",null,"On the mainnet, the Ethanos cycle lasts approximately 3 months, meaning that it takes 3 to 6 months for an inactive account to expire. The assessment of activity is based on the Ethanos cycle, so if you were active near the end of a cycle, your account could remain active for one more cycle. Conversely, if you were active at the beginning, your account could last for two cycles."),(0,o.kt)("h3",{id:"actions-to-take"},"Actions to Take"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"If Your Account is Expired"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Do not worry; it can be restored without any penalties. ",(0,o.kt)("a",{parentName:"li",href:"/developers/how-can-i-restore-my-account"},"How?")),(0,o.kt)("li",{parentName:"ul"},"To restore your accounts, you can request to ",(0,o.kt)("a",{parentName:"li",href:"/operators/operate-restoration-client"},"restoration client")," for the restoration."),(0,o.kt)("li",{parentName:"ul"},"Currently, you need to operate your own restoration client, but future services will provide more convenient restoration options.")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"If Your Account is Not Expired"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Ensure that accounts, especially contract accounts, are periodically used to prevent expiration. Usage is defined as any transaction that queries the contract account's state or calls its functions, including view functions."),(0,o.kt)("li",{parentName:"ul"},"Regularly monitor account activity to avoid unintentional expiration and ensure continuity of service. A monitoring tool will be available soon."),(0,o.kt)("li",{parentName:"ul"},"Especially for contract accounts with significant storage, prevent expiration as restoring storage can be costly. Future advancements will improve storage management efficiency, but for now, some monitoring and inconvenience are necessary.")),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"For contract accounts, especially those with extensive storage, expiration can be costly to restore. While we are developing more efficient storage management techniques, please bear with the current monitoring requirements to prevent expiration.")),(0,o.kt)("h2",{id:"you-cant-use-the-same-contract-address-in-ethereum"},"You Can't Use the Same Contract Address in Ethereum"),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"While the same Externally Owned Account (EOA) address can be used across various EVM-compatible chains with the same private key, this does not apply to contract addresses.")),(0,o.kt)("p",null,"Due to the state expiry feature in OverProtocol, all accounts, including contract accounts, could eventually expire. To mitigate the risk of an expired contract address being reused by a newly created contract, the contract creation operation always incorporates the caller account's ",(0,o.kt)("inlineCode",{parentName:"p"},"restoredEpoch")," value. This inclusion alters the outcome of the ",(0,o.kt)("inlineCode",{parentName:"p"},"CREATE")," operation, making the resulting addresses differ from those on other EVM chains."),(0,o.kt)("p",null,"As a result, even though the ",(0,o.kt)("inlineCode",{parentName:"p"},"CREATE2")," operation allows for deterministic address prediction and usage, it is not possible to reuse the same address across different chains as you would with EOA addresses."),(0,o.kt)("h3",{id:"actions-to-take-1"},"Actions to Take"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Be aware that contract addresses on OverProtocol will differ from those on Ethereum and other EVM-compatible chains due to the inclusion of the ",(0,o.kt)("inlineCode",{parentName:"li"},"restoredEpoch")," value."),(0,o.kt)("li",{parentName:"ul"},"When deploying contracts, account for the different address derivation method and plan your deployment strategy accordingly.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"// Create creates a new contract using code as deployment code.\nfunc (evm *EVM) Create(caller ContractRef, code []byte, gas uint64, value *big.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) {\n  contractAddr = crypto.CreateAddress(caller.Address(), evm.StateDB.GetRestoredEpoch(caller.Address()), evm.StateDB.GetNonce(caller.Address()))\n  return evm.create(caller, &codeAndHash{code: code}, gas, value, contractAddr, CREATE)\n}\n\n// Create2 creates a new contract using code as deployment code.\n//\n// The different between Create2 with Create is Create2 uses keccak256(0xff ++ msg.sender ++ salt ++ keccak256(init_code))[12:]\n// instead of the usual sender-and-nonce-hash as the address where the contract is initialized at.\nfunc (evm *EVM) Create2(caller ContractRef, code []byte, gas uint64, endowment *big.Int, salt *uint256.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) {\n  codeAndHash := &codeAndHash{code: code}\n  contractAddr = crypto.CreateAddress2(caller.Address(), salt.Bytes32(), codeAndHash.Hash().Bytes())\n  return evm.create(caller, codeAndHash, gas, endowment, contractAddr, CREATE2)\n}\n")),(0,o.kt)("h2",{id:"transaction-has-a-restoredepoch-field"},"Transaction has a ",(0,o.kt)("inlineCode",{parentName:"h2"},"restoredEpoch")," Field"),(0,o.kt)("p",null,"In traditional blockchain architectures, the ",(0,o.kt)("inlineCode",{parentName:"p"},"nonce")," primarily tracks the number of transactions sent from a given account, ensuring transaction order and preventing double-spending. However, due to the expiration feature in OverProtocol, distinguishing explicitly between expired accounts and newly created accounts becomes challenging, raising the possibility of ",(0,o.kt)("inlineCode",{parentName:"p"},"nonce")," overlap. To address this issue, OverProtocol introduces the ",(0,o.kt)("inlineCode",{parentName:"p"},"restoredEpoch")," as a crucial component."),(0,o.kt)("h3",{id:"restoredepoch"},"RestoredEpoch"),(0,o.kt)("p",null,"The combination of the ",(0,o.kt)("inlineCode",{parentName:"p"},"nonce")," and the ",(0,o.kt)("inlineCode",{parentName:"p"},"restoredEpoch")," value ensures uniqueness for each account. This system allows OverProtocol to maintain the integrity and distinction of account states over time, even through periods of account inactivity and expiration."),(0,o.kt)("p",null,"For a more detailed explanation, please refer to the ",(0,o.kt)("a",{parentName:"p",href:"/learn/key-features/layered-architecture/ethanos#dealing-with-crumb-accounts-restored-epoch"},"documentation"),"."),(0,o.kt)("h4",{id:"nonce-field-in-transaction"},(0,o.kt)("inlineCode",{parentName:"h4"},"nonce")," Field in Transaction"),(0,o.kt)("p",null,"The existing ",(0,o.kt)("inlineCode",{parentName:"p"},"nonce")," field is split into a 64-bit field, with the first 32 bits representing the ",(0,o.kt)("inlineCode",{parentName:"p"},"restoredEpoch")," and the remaining 32 bits functioning as the traditional ",(0,o.kt)("inlineCode",{parentName:"p"},"nonce"),". This adaptation allows developers to leverage existing Ethereum development environments while accommodating the unique features of OverProtocol."),(0,o.kt)("h3",{id:"actions-to-take-2"},"Actions to Take"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Learn how ",(0,o.kt)("inlineCode",{parentName:"li"},"restoredEpoch")," functions and its interaction with the nonce to ensure each account's uniqueness."),(0,o.kt)("li",{parentName:"ul"},"Use RPC requests like ",(0,o.kt)("inlineCode",{parentName:"li"},"eth_getTransactionCount")," when making transactions. The response will include the correct ",(0,o.kt)("inlineCode",{parentName:"li"},"nonce")," value, considering both ",(0,o.kt)("inlineCode",{parentName:"li"},"nonce")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"restoredEpoch"),".")),(0,o.kt)("h2",{id:"misc"},"Misc"),(0,o.kt)("h3",{id:"selfdestruct-operation"},(0,o.kt)("inlineCode",{parentName:"h3"},"SELFDESTRUCT")," Operation"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"SELFDESTRUCT")," opcode, updated in accordance with ",(0,o.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-6780"},(0,o.kt)("inlineCode",{parentName:"a"},"EIP-6780")),", is implemented in such a way that while it does not actually destroy the contract account, it does process refunds. Contracts that are not used will naturally expire over time as the Ethanos epoch progresses."),(0,o.kt)("p",null,"The rationale behind incorporating EIP-6780 into OverProtocol differs significantly from its application in Ethereum. OverProtocol's implementation is specifically designed to avoid scenarios where a self-destructed contract account becomes indistinguishable from an Externally Owned Account (EOA). This distinction is crucial for maintaining clarity and integrity in the network's account management, ensuring that the lifecycle of contract accounts is handled in a better way."),(0,o.kt)("h2",{id:"future-changes"},"Future Changes"),(0,o.kt)("p",null,"As OverProtocol progresses towards the Ethanos endgame, significant changes are planned, particularly regarding how storage is managed within accounts. These adjustments will be designed to ensure that backward compatibility is maximally preserved and that a seamless migration can occur. This means that current dApp developers should not be overly concerned about the impending changes."),(0,o.kt)("h3",{id:"storage-layout-change"},"Storage Layout Change"),(0,o.kt)("p",null,"Upcoming updates to OverProtocol will include a comprehensive overhaul of the storage layout within accounts. This change aims to enhance the efficiency and scalability of data management on the blockchain. Details on the new storage system will be provided as development progresses, ensuring developers have ample time to adapt their applications. This transition is intended to be smooth, with support structures in place to assist developers in migrating existing applications without disruption."))}p.isMDXComponent=!0}}]);